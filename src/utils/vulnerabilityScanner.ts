import { generateObject } from "ai";
import { z } from "zod";
import { createGoogleGenerativeAI } from "@ai-sdk/google";

export interface VulnerabilityResult {
  vulnerabilities: {
    line: number;
    description: string;
    severity: "critical" | "high" | "medium" | "low" | "info";
    type: string;
    recommendation: string;
  }[];
  summary?: string;
}

function generateHash(str: string): string {
  let hash = 0;
  if (str.length === 0) return hash.toString();

  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }

  return hash.toString();
}

const vulnerabilityScanCache = new Map<string, VulnerabilityResult>();

const apiKey = import.meta.env.VITE_GOOGLE_API_KEY;

if (!apiKey) {
  console.error(
    "Google API Key not found. Please set VITE_GOOGLE_API_KEY in your .env file."
  );
}

const google = createGoogleGenerativeAI({
  apiKey: apiKey,
});

const model = google("gemini-2.5-pro-exp-03-25", {
  structuredOutputs: true,
});

export async function scanForVulnerabilities(
  code: string,
  language?: string
): Promise<VulnerabilityResult> {
  const cacheKey = generateHash(`${code}_${language || ""}`);

  if (vulnerabilityScanCache.has(cacheKey)) {
    console.log("Using cached vulnerability scanning result");
    return vulnerabilityScanCache.get(cacheKey)!;
  }

  try {
    const prompt = `
You are a cybersecurity expert specialized in code security reviews. Analyze the provided code carefully to identify security vulnerabilities:

1. Identify security vulnerabilities like XSS, SQL injection, CSRF, insecure authentication, etc.
2. Flag any use of unsafe functions, outdated libraries, or deprecated methods
3. Detect potential data leaks, hardcoded credentials, or API keys
4. Identify potential privilege escalation issues
5. Find insecure cryptographic practices or weak random number generation
6. Look for issues with file permissions, path traversal vulnerabilities
7. Check for insecure deserialization or dangerous eval usage
8. Identify missing input validation or improper error handling
9. Be precise with line numbers and context

Format your response as a JSON object with an array of vulnerabilities:
{
  "vulnerabilities": [
    {
      "line": <starting line number>,
      "description": "<detailed description of the vulnerability>",
      "severity": "<critical|high|medium|low|info>",
      "type": "<vulnerability category - e.g. XSS, Injection, Insecure Auth>",
      "recommendation": "<specific fix recommendation>"
    },
    ...
  ],
  "summary": "<optional brief summary of security posture>"
}
`;
    const { object } = await generateObject({
      system: prompt,
      model,
      prompt: `
      Here is the ${language || "code"} code to review for vulnerabilities:
      \`\`\`
      ${code}
      \`\`\`
      Please provide your security analysis in the specified JSON format.`,
      schema: z.object({
        vulnerabilities: z.array(
          z.object({
            line: z.number(),
            description: z.string(),
            severity: z.enum(["critical", "high", "medium", "low", "info"]),
            type: z.string(),
            recommendation: z.string(),
          })
        ),
        summary: z.string().optional(),
      }),
    });

    const result = object as VulnerabilityResult;

    vulnerabilityScanCache.set(cacheKey, result);

    return result;
  } catch (error) {
    console.error("Error scanning for vulnerabilities:", error);
    return {
      vulnerabilities: [
        {
          line: 1,
          description:
            "An error occurred while analyzing the code for vulnerabilities. Please try again.",
          severity: "info",
          type: "Analysis Error",
          recommendation:
            "Try again with a different code sample or check your connection.",
        },
      ],
    };
  }
}
